// import * as React from 'react';
import React, { useCallback, useEffect, useRef, useState } from "react";
import { useDispatch } from "react-redux";

import {
  fileExcelIcon,
  filePdfIcon,
  chevronDoubleDownIcon,
  chevronDoubleRightIcon,
  gearIcon,
  columnsIcon,
  moreVerticalIcon,
} from "@progress/kendo-svg-icons";
import {
  Grid,
  GridColumn as Column,
  getSelectedState,
  GridToolbar,
} from "@progress/kendo-react-grid";
import {
  setExpandedState,
  getGroupIds,
  stringOperator,
} from "@progress/kendo-react-data-tools";
import { getter } from "@progress/kendo-react-common";
import { process } from "@progress/kendo-data-query";
import { SvgIcon } from "@progress/kendo-react-common";
import { Checkbox, Input } from "@progress/kendo-react-inputs";
import { Popup } from "@progress/kendo-react-popup";
import { GridPDFExport } from "@progress/kendo-react-pdf";
import { ExcelExport } from "@progress/kendo-react-excel-export";
import {
  Button,
  Card,
  CardContent,
  Container,
  Typography,
} from "@mui/material";
import FileDownloadOutlinedIcon from "@mui/icons-material/FileDownloadOutlined";

import ReactSanitizedHtml from "react-sanitized-html";

import "../EasaRegisterList.Component.scss";

export function getNestedValue(fieldName, dataItem) {
  const path = (fieldName || "").split(".");
  let data = dataItem;
  path.forEach((p) => {
    data = data ? data[p] : undefined;
  });

  return data;
}

const getHighlight = (value, filter) => {
  let index = value.toLocaleLowerCase().indexOf(filter.toLocaleLowerCase());
  if (index >= 0) {
    let left = value.substr(0, index);
    let right = value.substring(index + filter.length, value.length);
    return (
      <React.Fragment>
        {left}
        <span style={{ backgroundColor: "#a8edb3" }}>
          {value.substr(index, filter.length)}
        </span>
        {getHighlight(right, filter)}
      </React.Fragment>
    );
  }
  return value;
};

function highlightSearchTextInReactChildren(children, searchText) {
  function highlightInNode(node: React.ReactNode) {
    if (typeof node === "string") {
      const modifiedContent = node.replace(
        new RegExp(`(${searchText})`, "gi"),
        '<span style="background-color:#a8edb3">$1</span>'
      );
      if (node !== modifiedContent) {
        return (
          <span>
            <ReactSanitizedHtml html={modifiedContent} />
          </span>
        );
      }
    } else if (React.isValidElement(node)) {
      const children = node.props.children;
      if (children != null) {
        if (Array.isArray(children)) {
          return React.cloneElement(
            node,
            {},
            children.map((ch, index) => highlightInNode(ch))
          );
        } else {
          return React.cloneElement(node, {}, highlightInNode(children));
        }
      }
    }

    return node;
  }
  return React.Children.map(children, (child: React.ReactNode) => {
    return highlightInNode(child);
  });
}

const getNumberOfItems = (data) => {
  let count = 0;
  data.forEach((item) => {
    if (item.items) {
      if (item.expanded) {
        count = count + getNumberOfItems(item.items);
      }
    } else {
      count++;
    }
  });
  return count;
};
const getNumberOfSelectedItems = (data) => {
  let count = 0;
  data.forEach((item) => {
    if (item.items) {
      if (item.expanded) {
        count = count + getNumberOfSelectedItems(item.items);
      }
    } else {
      count = count + (item.selected === true ? 1 : 0);
    }
  });
  return count;
};

const generateGroupIds = (data) => {
  data.forEach((item) => {
    if (item.aggregates) {
      item.groupId = item.field + "_" + item.value;
      generateGroupIds(item.items);
    }
  });
};

const getDataColumnsTitles = (gridChildren) => {
  let columns = {};
  gridChildren.forEach((child) => {
    if (child !== ",") {
      if (
        child.type?.displayName === "KendoReactGridColumn" &&
        child.props.field &&
        child.props.field !== "selected"
      ) {
        var excludedFields: string[] = [
          "CREATION_DATE",
          "CREATED_Name",
          "MODIFICATION_DATE",
          "MODIFIED_Name",
          "PREPARED_BY_NAME",
          "APPROVED_BY_NAME",
          "ORGANISATION_TYPE",
          "DO_PO_MO",
          "COMMENTS",
        ];
        const isFieldExcluded = excludedFields.includes(child.props.field);
        if (!isFieldExcluded) {
          columns[child.props.title ?? child.props.field] = true;
        } else {
          columns[child.props.title ?? child.props.field] = false;
        }
      }
    }
  });
  return columns;
};

const getGridFieldColumns = (gridChildren) => {
  let fieldColumns: Array<any> = [];
  gridChildren.map((child: any) => {
    if (child !== ",") {
      if (
        child.type?.displayName === "KendoReactGridColumn" &&
        child.props &&
        child.props.field &&
        child.props.field !== "selected"
      ) {
        fieldColumns.push(child.props);
      }
    }
  });
  return fieldColumns;
};
const TOOLBAR_BUTTON_TYPE = "primary";

export const GridHelper = (props) => {
  const {
    externalFilter,
    expandCollapseAllButton,
    excelExportButton,
    pdfExportButton,
    showColumnsConfigurator,
    showFeaturesConfigurator,
    filterHighlights,
  } = props.toolbarSettings ?? {};

  const GridProps = props.children.props;
  const GridChildrenProps = GridProps.children[2];
  console.log(props.children.props, 'props');

  const [filterValue, setFilterValue] = React.useState<String | null>(null);

  // Needed for toggling features from the configurator
  const [defaultConfiguration, setDefaultConfiguration] = React.useState({
    filterable: props.filterable ?? GridProps.filterable,
    selectable: props.selectable ?? GridProps.selectable,
    sortable: props.sortable ? props.sortable : GridProps.sortable,
    groupable: props.groupable ?? GridProps.groupable,
    pageable: props.pageable ?? GridProps.pageable,
  });

  const [configuration, setConfiguration] = React.useState({
    ...defaultConfiguration,
  });

  React.useEffect(() => {
    setConfiguration({
      ...configuration,
      pageable: props.pageable ?? GridProps.pageable,
    });
  }, [props.pageable, GridProps.pageable]);

  React.useEffect(() => {
    setConfiguration({
      ...configuration,
      filterable: props.filterable ?? GridProps.filterable,
    });
  }, [props.filterable, GridProps.filterable]);

  React.useEffect(() => {
    setConfiguration({
      ...configuration,
      groupable: props.groupable ?? GridProps.groupable,
    });
  }, [props.groupable, GridProps.groupable]);

  React.useEffect(() => {
    setConfiguration({
      ...configuration,
      selectable: props.selectable ?? GridProps.selectable,
    });
  }, [props.selectable, GridProps.selectable]);

  React.useEffect(() => {
    setDefaultData(props.data ?? GridProps.data);
    setData(props.data ?? GridProps.data);
  }, [props.data, GridProps.data]);

  // The raw data
  const [defaultData, setDefaultData] = React.useState(
    (props.data ?? GridProps.data).map((dataItem) =>
      Object.assign(
        {
          selected: false,
        },
        dataItem
      )
    )
  );
  const [exportColumns, setExportColumns] = React.useState<Array<any>>(
    getGridFieldColumns(GridChildrenProps)
  );
  const [data, setData] = React.useState(defaultData);
  const idGetter = getter(props.dataItemKey ?? GridProps.dataItemKey);
  const [dataState, setDataState] = React.useState(
    props.initialDataState ?? { skip: null }
  );
  const [columnsState, setColumnsState] = React.useState(
    getDataColumnsTitles(GridChildrenProps)
  );
  const [selectedState, setSelectedState] = React.useState({});
  const [collapsedState, setCollapsedState] = React.useState<string[]>([]);
  const [total, setTotal] = React.useState(data.length);

  // Updates the configuration settings
  const updateConfiguration = (setting, state) => {
    let defaultValue = defaultConfiguration[setting];
    let newSettings = {
      ...configuration,
    };

    // if the property state is "true", use the defaultValue (if it was set initially). This handles the case
    // where "pageable" and "sortable" settings are initially objects
    newSettings[setting] = state ? (defaultValue ? defaultValue : true) : false;
    if (setting === "pageable") {
      setDataState({ ...dataState, take: state ? 10 : null });
    } else if (setting === "groupable" && !state) {
      setDataState({ ...dataState, group: null });
    } else if (setting === "filterable" && !state) {
      setDataState({ ...dataState, filter: null });
    }
    setConfiguration(newSettings);
  };

  // Updates the columns visibility state
  const updateColumns = (setting, state) => {
    let newState = { ...columnsState };
    newState[setting] = state;
    setColumnsState(newState);
  };

  // const onDataStateChange = (ev) => {
  //
  //   setDataState(ev.dataState);
  // };

  const onExpandChange = React.useCallback(
    (event) => {
      const item = event.dataItem;
      if (item.groupId) {
        const newCollapsedIds = !event.value
          ? [...collapsedState, item.groupId]
          : collapsedState.filter((groupId) => groupId !== item.groupId);
        setCollapsedState(newCollapsedIds);
      }
    },
    [collapsedState]
  );

  // All data operations, except the external filter, are handled here
  const finalData = React.useMemo(() => {

    let processedData = data.map((item) => ({
      ...item,
      // [props.selectedField ? props.selectedField : 'selected']:
      //   selectedState[idGetter(item)]
    }));
    dataState.sort = GridProps?.sort;
    dataState.filter = GridProps?.filter;
    processedData = process(processedData, dataState);
    processedData.total = GridProps.total;
    setTotal(processedData.total);
    generateGroupIds(processedData.data);
    processedData = setExpandedState({
      data: processedData.data,
      collapsedIds: collapsedState,
    });
    return processedData;
  }, [
    data,
    dataState,
    setDataState,
    selectedState,
    setSelectedState,
    collapsedState,
    setCollapsedState,
  ]);

  const newProps = {
    ...props.children.props,
    children: null,
    data: finalData,
    ...dataState,
    total: total,
    onExpandChange: onExpandChange,
    expandField: props.expandedField ?? GridProps.expandedField ?? "expanded",
    // selectedField: props.selectedField ?? GridProps.selectedField ?? 'selected'
  };

  const onGroupsToggle = React.useCallback(() => {
    setCollapsedState(
      collapsedState.length ? [] : getGroupIds({ data: finalData })
    );
  }, [collapsedState, dataState]);

  const onExternalFilterChange = (ev) => {
    const value = ev.value;
    setFilterValue(ev.value);
    let visibleColumnsFields = {};
    GridProps.children.map((child) => {
      if (child !== ",") {
        if (
          child.type?.displayName === "KendoReactGridColumn" &&
          columnsState[child.props.title ?? child.props.field]
        ) {
          visibleColumnsFields[child.props.field] = true;
        }
      }
    });

    let newData = defaultData.filter((item) => {
      let match = false;

      for (const property in visibleColumnsFields) {
        if (visibleColumnsFields[property]) {
          if (
            getNestedValue(property, item)
              .toString()
              .toLocaleLowerCase()
              .indexOf(value.toLocaleLowerCase()) >= 0
          ) {
            match = true;
          }

          if (
            getNestedValue(property, item).toLocaleDateString &&
            getNestedValue(property, item)
              .toLocaleDateString()
              .indexOf(value) >= 0
          ) {
            match = true;
          }
        }
      }
      return match;
    });
    setData(newData);
  };

  const cellRender = React.useCallback(
    (td, props) => {
      if (props.rowType === "data") {
        const value = getNestedValue(props.field, props.dataItem)?.toString();

        if (!value) {
          return td;
        }
        if (
          filterValue &&
          filterValue.length > 0 &&
          value.toLocaleLowerCase().indexOf(filterValue.toLocaleLowerCase()) >=
            0
        ) {
          const children = highlightSearchTextInReactChildren(
            td.props.children,
            filterValue
          );
          return React.cloneElement(td, [props], [children]);
        }
      }

      return td;
    },
    [filterValue]
  );

  const _pdfExport = React.useRef<GridPDFExport | null>(null);
  const exportToPdf = () => {
    if (_pdfExport.current) {
      _pdfExport.current.save();
    }
  };
  const dispatch = useDispatch();

  const ExportfetchData = async (dataState) => {
    var DdtlExcelData = [];
    try {
      //dispatch(incrementApiCount());
      const sortVal = {
        field:
          dataState?.sort != undefined && dataState?.sort?.length != 0
            ? dataState?.sort[0].field
            : null,
        dir:
          dataState?.sort != undefined && dataState?.sort?.length != 0
            ? dataState?.sort[0].dir
            : null,
      };

      // let filterVal: ParameterObject[] = [];
      // let filterObjects: FilterParam[] = [];
      //dataState.filter.filters[0].filters[0].field
      // if (dataState.filter != undefined && dataState.filter.length != 0) {
      //     if (dataState.filter.filters.length != 0) {
      //         for (let i = 0; i < dataState.filter.filters.length; i++) {

      //             if (dataState.filter.filters[i].filters.length != 0) {
      //                 filterVal = [];
      //                 for (let j = 0; j < dataState.filter.filters[i].filters.length; j++) {
      //                     const parameterObject: ParameterObject = {
      //                         field: dataState.filter.filters[i].filters[j].field,
      //                         operator: dataState.filter.filters[i].filters[j].operator,
      //                         value: dataState.filter.filters[i].filters[j].value
      //                     };

      //                     filterVal.push(parameterObject);
      //                 }

      //                 const filterObj: FilterParam = {
      //                     filterObject: filterVal,
      //                     logic: dataState.filter.filters[i].logic
      //                 };
      //                 filterObjects.push(filterObj);

      //             }

      //         }
      //     }
      // }

      const gridDataModel = {
        skip: 0,
        take: 0,
        sort: sortVal,
        filter: [],
      };

      // console.log(document.getElementById("removeFavBtn") != null ? true : false, "export")

      // await DdtlService.exportDDTLData(document.getElementById("removeFavBtn") != null ? true : false, gridDataModel).then((response) => {
      //     const responseData = response;
      //     DdtlExcelData = response.data.Result;

      //     DdtlExcelData.forEach(data => {

      //         if (data.APPROVAL_DATE) {
      //             var val = data.APPROVAL_DATE;
      //             const DateVal = new Date(val);
      //             const formattedDate = `${(DateVal.getMonth() + 1).toString().padStart(2, '0')}/${DateVal.getDate().toString().padStart(2, '0')}/${DateVal.getFullYear().toString()}`;
      //             data.APPROVAL_DATE = formattedDate;
      //         }
      //         if (data.DATE_SENT) {
      //             var val = data.DATE_SENT;
      //             const DateVal = new Date(val);
      //             const formattedDate = `${(DateVal.getMonth() + 1).toString().padStart(2, '0')}/${DateVal.getDate().toString().padStart(2, '0')}/${DateVal.getFullYear().toString()}`;
      //             data.DATE_SENT = formattedDate;
      //         }
      //         if (data.CREATION_DATE) {
      //             var val = data.CREATION_DATE;
      //             const DateVal = new Date(val);
      //             const formattedDate = `${(DateVal.getMonth() + 1).toString().padStart(2, '0')}/${DateVal.getDate().toString().padStart(2, '0')}/${DateVal.getFullYear().toString()}`;
      //             data.CREATION_DATE = formattedDate;
      //         }
      //         if (data.MODIFICATION_DATE) {
      //             var val = data.MODIFICATION_DATE;
      //             const DateVal = new Date(val);
      //             const formattedDate = `${(DateVal.getMonth() + 1).toString().padStart(2, '0')}/${DateVal.getDate().toString().padStart(2, '0')}/${DateVal.getFullYear().toString()}`;
      //             data.MODIFICATION_DATE = formattedDate;
      //         }

      //     });
      //     dispatch(decrementApiCount());
      // });
    } catch (error) {
      console.error("Error", error);
    }
    return DdtlExcelData;
  };

  function getProjectRegisterfilename() {
    var today = new Date();
    var y = today.getFullYear();
    var m = today.getMonth() + 1;
    var d = today.getDate();
    var h = today.getHours();
    var mi = today.getMinutes();
    var s = today.getSeconds();
    return (
      "DDTL_" + m + "-" + d + "-" + y + "-" + h + "-" + mi + "-" + s + ".xlsx"
    );
  }

  const _excelExport = React.useRef<ExcelExport | null>(null);
  const exportToExcel = () => {
    dataState.sort = newProps.sort;
    dataState.filter = newProps.filter;
    var DdtlExcelDatasList = ExportfetchData(dataState).then((response) => {
      if (_excelExport.current) {
        _excelExport.current.save(response);
      }
    });
  };

  const gridChildren = React.useMemo(() => {
    const toolBar = GridProps.children.find(
      (c) => c.type?.displayName === "KendoReactGridToolbar"
    );
    console.log(GridProps.children, 'GridProps');
    const gridToolBar = (
      <GridToolbar key="grid-toolbar" {...toolBar?.props}>
        {expandCollapseAllButton && configuration.groupable && (
          <div>
            <ExpandCollapseButton
              onClick={onGroupsToggle}
              collapse={!collapsedState.length}
            />
          </div>
        )}

        {externalFilter && (
          <div>
            <ExternalFilter
              filterValue={filterValue}
              onChange={onExternalFilterChange}
            />
          </div>
        )}

        {toolBar && toolBar.props.children && (
          <div>{toolBar.props.children}</div>
        )}

        <div
          className="grid-right-icons"
          style={{
            right: "-11px",
            float: "right",
            position: "absolute",
            display: "flex",
          }}
        >
          <div>
            {excelExportButton && (
              <Button
                className="exportBtn"
                onClick={exportToExcel}
                variant={"outlined"}
                size={"small"}
                color={"inherit"}
                title={"Export to Excel"}
              >
                {/* <FontAwesomeIcon icon={faDownload}  /> */}
                {/* {<img src={icon_download} alt="React Image" /> } */}
                <FileDownloadOutlinedIcon
                  color="disabled"
                  className="iconClass"
                />
                <Typography variant={"button"} sx={{ textTransform: "none" }}>
                  Export
                </Typography>
              </Button>
            )}
          </div>
          <div>
            {pdfExportButton && (
              <Button
                onClick={exportToPdf}
                variant={"outlined"}
                size={"small"}
                color={"inherit"}
                // themeColor={TOOLBAR_BUTTON_TYPE}
                title={"Export to PDF"}
              >
                <SvgIcon icon={filePdfIcon} size="medium" />
              </Button>
            )}
          </div>
          <div className="showHideDiv" style={{ marginTop: "5px" }}>
            {showColumnsConfigurator && (
              <ColumnsButton onChange={updateColumns} options={columnsState} />
            )}
          </div>

          <div>
            {showFeaturesConfigurator && (
              <ConfiguratorButton
                onChange={updateConfiguration}
                options={configuration}
              />
            )}
          </div>
        </div>

        {/* <div>
            {(
              <Button disabled={deleteButton} className="displayBlock  marginLeft10" id="deleteBtn" title="Delete" onClick={onOpenModal}><FontAwesomeIcon icon={faTrash} /> Delete</Button>
            )}
          </div> */}
      </GridToolbar>
    );

    let children = GridChildrenProps.map((child, index) => {
      console.log(GridProps.children, 'GridProps.children')
      if (child !== ",") {
        if (child.type?.displayName === "KendoReactGridColumn") {
          if (child.props.field === newProps.selectedField) {
            return (
              <Column
                key={index}
                {...child.props}
                // headerSelectionValue={headerSelectionValue()}
              />
            );
          } else if (columnsState[child.props.title ?? child.props.field]) {
            return <Column {...child.props} key={index} />;
          } else if (!child.props.field) {
            return <Column {...child.props} key={index} />;
          }
        } else if (child.type?.displayName === "KendoReactGridToolbar") {
          return null;
        } else {
          return child;
        }
      }
    });

    if (props.toolbarSettings) {
      children.push(gridToolBar);
    } else if (toolBar) {
      children.push(toolBar);
    }
    console.log(children, 'children');
     return children;
  }, [
    GridProps.children,
    columnsState,
    collapsedState,
    configuration,
    dataState,
    filterValue,
  ]);

  const gridRef = React.useRef<any>(null);
  const [calculatedDynamicColWidth, setCalculatedDynamicColWidth] = useState(0);
  const [multipleSelected, setmultipleSelected] = useState(false);
  const [totalColumnFixedWidth, setTotalColumnFixedWidth] = useState(0);

  useEffect(() => {
    if (gridRef?.current) {
      const headerCells = gridRef.current.element.querySelectorAll(".k-header");
      let calculatedFixedColumnWidth = 0;
      let dynamicWidth = 0;
      headerCells.forEach((cell, index) => {
        if (gridRef.current.columns[index].width != undefined) {
          if (
            gridRef.current.columns[index].width.toString().indexOf("px") > -1
          ) {
            calculatedFixedColumnWidth =
              calculatedFixedColumnWidth +
              parseInt(gridRef.current.columns[index].width);
          } else {
            dynamicWidth = dynamicWidth + gridRef.current.columns[index].width;
          }
        }
        const columnHeader = gridRef.current.columns[index].title;
        cell.title = columnHeader;
      });
      setCalculatedDynamicColWidth(dynamicWidth);
      setTotalColumnFixedWidth(calculatedFixedColumnWidth);
    }
  }, [gridRef, data, columnsState]);

  const renderedGridProps = {
    ...newProps,
    ...configuration,
    children: gridChildren,
    ref: gridRef,
  };

  if (filterHighlights) {
    renderedGridProps.cellRender = cellRender;
  }

  const GridComponent = <Grid {...renderedGridProps} />;

  return (
    <React.Fragment>
      <GridPDFExport ref={_pdfExport} margin="1cm">
        {GridComponent}
      </GridPDFExport>
      <ExcelExport
        data={finalData}
        ref={_excelExport}
        columns={exportColumns.filter(
          (col) => columnsState[col.title ?? col.field]
        )}
        group={dataState.group}
        fileName={getProjectRegisterfilename()}
      />
      {GridComponent}
    </React.Fragment>
  );
};

// ExternalFilter
const ExternalFilter = (props) => {
  return (
    <React.Fragment>
      <span style={{ padding: "5px" }}>Search: </span>
      <span>
        <Input
          value={props.filterValue}
          onChange={props.onChange}
          style={{
            border: "2px solid #ccc",
            boxShadow: "inset 0px 0px 0.5px 0px rgba(0,0,0,0.0.1)",
          }}
        />
      </span>
    </React.Fragment>
  );
};
// Expand/Collapse All Groups button
const ExpandCollapseButton = (props) => {
  return (
    <Button
      onClick={props.onClick}
      // themeColor={TOOLBAR_BUTTON_TYPE}
      size="small"
      color={"inherit"}
      title={(!props.collapse ? "Expand" : "Collapse") + " all groups"}
    >
      {props.collapse ? (
        <SvgIcon icon={chevronDoubleDownIcon} size="medium" />
      ) : (
        <SvgIcon icon={chevronDoubleRightIcon} size="medium" />
      )}
    </Button>
  );
};

// Columns show/hide
const ColumnsButton = (props) => {
  return (
    <ConfiguratorButtonBase
      {...props}
      icon={moreVerticalIcon}
      title="Show/Hide Columns"
    />
  );
};

// Settings button
const ConfiguratorButton = (props) => {
  return <ConfiguratorButtonBase {...props} icon={gearIcon} title="Settings" />;
};

// Button showing popup with all properties of an object
// props.options is the object with the properties that will be rendered in the checkbox list
// props.icon is the name of the button icon
// props.title sets the title of the button
// props.onChange returns the toggled option/property
const ConfiguratorButtonBase = (props) => {
  const anchor = React.useRef(null);
  const [show, setShow] = React.useState(false);
  const onClick = () => {
    setShow(!show);
  };

  const onChange = (ev) => {
    let setting = ev.target.element.attributes["data-attr"].value;
    props.onChange(setting, ev.value);
  };

  React.useEffect(() => {
    const onMouseDown = (event) => {
      let wrappingEl = document.querySelector(".configurator-wrap-element");
      if (wrappingEl && !wrappingEl.contains(event.target)) {
        setShow(false);
      }
    };

    window.addEventListener("mousedown", onMouseDown);
    return () => window.removeEventListener("mousedown", onMouseDown);
  }, []);

  return (
    <React.Fragment>
      <span ref={anchor} title={props.title}>
        <Button
          onClick={onClick}
          // themeColor={TOOLBAR_BUTTON_TYPE}
          size={"small"}
          color={"inherit"}
        >
          <SvgIcon icon={props.icon} size="medium" />
        </Button>
      </span>
      <Popup
        margin={{ horizontal: 10, vertical: 10 }}
        anchor={anchor.current}
        anchorAlign={{ vertical: "bottom", horizontal: "right" }}
        popupAlign={{ vertical: "top", horizontal: "right" }}
        show={show}
      >
        <div
          className="configurator-wrap-element"
          style={{
            padding: "10px",
            backgroundColor: "#fefefe",
            border: "1px solid #ddd",
          }}
        >
          <div style={{ paddingBottom: "5px" }}>{props.title}:</div>
          <div>
            {Object.keys(props.options).map((setting, index) => {
              let checked =
                props.options[setting] != null &&
                props.options[setting] !== false;
              return (
                <div style={{ padding: "3px 5px 5px 0px" }} key={index}>
                  <Checkbox
                    value={checked}
                    onChange={onChange}
                    data-attr={setting}
                  />{" "}
                  {setting.charAt(0).toUpperCase() + setting.slice(1)}
                </div>
              );
            })}
          </div>
        </div>
      </Popup>
    </React.Fragment>
  );
};
