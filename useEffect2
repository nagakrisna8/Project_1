// InlineAIPromptWrapper.tsx
import React, { useEffect, useRef } from 'react';
import { InlineAIPrompt as KendoInlineAIPrompt } from '@progress/kendo-react-conversational-ui';

type InlineAIPromptWrapperProps = React.ComponentProps<typeof KendoInlineAIPrompt> & {
  promptRoot?: HTMLElement | undefined;
  anchor?: HTMLElement | undefined;
};

export default function InlineAIPromptWrapper(props: InlineAIPromptWrapperProps) {
  const { promptRoot, anchor, ...rest } = props;

  const currentRootRef = useRef<HTMLElement | undefined>(
    promptRoot ??
      (document.querySelector('.k-prompt-content') as HTMLElement | null) ??
      document.body
  );

  useEffect(() => {
    currentRootRef.current =
      promptRoot ??
      (document.querySelector('.k-prompt-content') as HTMLElement | null) ??
      document.body;
  }, [promptRoot]);

  useEffect(() => {
    const root = currentRootRef.current ?? document.body;

    const getAnchor = (): HTMLElement | undefined => {
      return anchor ?? ((window as any).__kendoAnchorForInlineAI as HTMLElement | undefined);
    };

    /* ---------------- Focus helpers ---------------- */

    const preserveFocus = () => document.activeElement as HTMLElement | null;

    const restoreFocus = (el: HTMLElement | null) => {
      try {
        el?.focus({ preventScroll: true });
      } catch {
        /* ignore */
      }
    };

    /* ---------------- Positioning ---------------- */

    const applyFixedPosition = (container: HTMLElement, anchorEl?: HTMLElement | null) => {
      try {
        const a = anchorEl ?? getAnchor();
        if (!a) return;

        const rect = a.getBoundingClientRect();

        container.style.setProperty('position', 'fixed', 'important');
        container.style.setProperty('left', `${Math.round(rect.left)}px`, 'important');
        container.style.setProperty('top', `${Math.round(rect.bottom - 80)}px`, 'important');
        container.style.setProperty('margin', '0', 'important');
        container.style.setProperty('transform', 'none', 'important');
        container.style.setProperty('z-index', '2147483647', 'important');
      } catch {
        /* ignore */
      }
    };

    const moveAndFix = (el: HTMLElement, anchorEl?: HTMLElement | null) => {
      try {
        const active = preserveFocus();

        if (!root.contains(el)) {
          root.appendChild(el);
        }

        applyFixedPosition(el, anchorEl);
        restoreFocus(active);
      } catch {
        /* ignore */
      }
    };

    const retryFix = (
      container: HTMLElement,
      anchorEl?: HTMLElement | null,
      attempts = 6,
      delay = 80
    ) => {
      let tries = 0;

      const tick = () => {
        tries++;
        const active = preserveFocus();
        applyFixedPosition(container, anchorEl);
        restoreFocus(active);

        if (tries >= attempts) return;
        setTimeout(tick, delay);
      };

      setTimeout(tick, delay);
    };

    /* ---------------- Helpers ---------------- */

    const isCommandPopup = (container: HTMLElement) => {
      try {
        return !!container.querySelector('.k-menu-popup, .k-popup.k-menu-popup, .k-menu');
      } catch {
        return false;
      }
    };

    /* ---------------- Initial scan ---------------- */

    document
      .querySelectorAll('.k-animation-container.k-animation-container-shown')
      .forEach((n) => {
        if (n instanceof HTMLElement && isCommandPopup(n)) {
          moveAndFix(n, anchor);
          retryFix(n, anchor);
        }
      });

    /* ---------------- Mutation observer (new popups) ---------------- */

    const mo = new MutationObserver((mutations) => {
      for (const m of mutations) {
        if (m.type !== 'childList' || !m.addedNodes.length) continue;

        m.addedNodes.forEach((node) => {
          if (!(node instanceof HTMLElement)) return;

          if (
            node.matches?.('.k-animation-container.k-animation-container-shown') &&
            isCommandPopup(node)
          ) {
            moveAndFix(node, anchor);
            retryFix(node, anchor);
            return;
          }

          const found =
            node.querySelector?.('.k-animation-container.k-animation-container-shown');

          if (found instanceof HTMLElement && isCommandPopup(found)) {
            moveAndFix(found, anchor);
            retryFix(found, anchor);
          }
        });
      }
    });

    mo.observe(document.body, { childList: true, subtree: true });

    /* ---------------- Attribute observer (Kendo style resets) ---------------- */

    const attrObserver = new MutationObserver((mutations) => {
      for (const m of mutations) {
        const target = m.target as HTMLElement;
        if (
          target?.matches?.('.k-animation-container.k-animation-container-shown') &&
          isCommandPopup(target)
        ) {
          const active = preserveFocus();
          applyFixedPosition(target, anchor);
          restoreFocus(active);
        }
      }
    });

    attrObserver.observe(document.body, {
      attributes: true,
      subtree: true,
      attributeFilter: ['style', 'class'],
    });

    return () => {
      mo.disconnect();
      attrObserver.disconnect();
    };
  }, [anchor, promptRoot]);

  /* ---------------- Render ---------------- */

  const appendToValue = currentRootRef.current ?? undefined;
  const InlineAny = KendoInlineAIPrompt as any;

  return <InlineAny {...(rest as any)} appendTo={appendToValue} anchor={anchor} />;
}
