// InlineAIPromptWrapper.tsx
import React, { useEffect, useRef } from 'react';
import { InlineAIPrompt as KendoInlineAIPrompt } from '@progress/kendo-react-conversational-ui';

type InlineAIPromptWrapperProps = React.ComponentProps<typeof KendoInlineAIPrompt> & {
  promptRoot?: HTMLElement;
  anchor?: HTMLElement;
};

export default function InlineAIPromptWrapper(props: InlineAIPromptWrapperProps) {
  const { promptRoot, anchor, ...rest } = props;

  const rootRef = useRef<HTMLElement | undefined>(
    promptRoot ??
      (document.querySelector('.k-prompt-content') as HTMLElement | null) ??
      document.body
  );

  useEffect(() => {
    rootRef.current =
      promptRoot ??
      (document.querySelector('.k-prompt-content') as HTMLElement | null) ??
      document.body;
  }, [promptRoot]);

  useEffect(() => {
    const getAnchor = (): HTMLElement | undefined => {
      return anchor ?? ((window as any).__kendoAnchorForInlineAI as HTMLElement | undefined);
    };

    /* ---------------------------------------------------
     * Position popup WITHOUT moving it in the DOM
     * --------------------------------------------------- */
    const applyFixedPosition = (container: HTMLElement) => {
      try {
        const a = getAnchor();
        if (!a) return;

        const rect = a.getBoundingClientRect();

        container.style.setProperty('position', 'fixed', 'important');
        container.style.setProperty('left', `${Math.round(rect.left)}px`, 'important');
        container.style.setProperty('top', `${Math.round(rect.bottom - 80)}px`, 'important');
        container.style.setProperty('margin', '0', 'important');
        container.style.setProperty('transform', 'none', 'important');
        container.style.setProperty('z-index', '2147483647', 'important');
      } catch {
        /* ignore */
      }
    };

    const isCommandPopup = (el: HTMLElement) => {
      try {
        return !!el.querySelector('.k-menu, .k-menu-popup, .k-popup.k-menu-popup');
      } catch {
        return false;
      }
    };

    /* ---------------------------------------------------
     * Initial scan (already opened popup)
     * --------------------------------------------------- */
    document
      .querySelectorAll<HTMLElement>('.k-animation-container.k-animation-container-shown')
      .forEach((el) => {
        if (isCommandPopup(el)) {
          applyFixedPosition(el);
        }
      });

    /* ---------------------------------------------------
     * Observe popup creation
     * --------------------------------------------------- */
    const mo = new MutationObserver((mutations) => {
      for (const m of mutations) {
        if (m.type !== 'childList') continue;

        m.addedNodes.forEach((node) => {
          if (!(node instanceof HTMLElement)) return;

          if (
            node.matches('.k-animation-container.k-animation-container-shown') &&
            isCommandPopup(node)
          ) {
            applyFixedPosition(node);
            return;
          }

          const found = node.querySelector?.(
            '.k-animation-container.k-animation-container-shown'
          );

          if (found instanceof HTMLElement && isCommandPopup(found)) {
            applyFixedPosition(found);
          }
        });
      }
    });

    mo.observe(document.body, { childList: true, subtree: true });

    /* ---------------------------------------------------
     * Observe style/class mutations (Kendo repositions)
     * --------------------------------------------------- */
    const attrObserver = new MutationObserver((mutations) => {
      for (const m of mutations) {
        const target = m.target as HTMLElement;

        if (
          target?.matches?.('.k-animation-container.k-animation-container-shown') &&
          isCommandPopup(target)
        ) {
          applyFixedPosition(target);
        }
      }
    });

    attrObserver.observe(document.body, {
      attributes: true,
      subtree: true,
      attributeFilter: ['style', 'class'],
    });

    return () => {
      mo.disconnect();
      attrObserver.disconnect();
    };
  }, [anchor, promptRoot]);

  /* ---------------------------------------------------
   * Render
   * --------------------------------------------------- */
  const InlineAny = KendoInlineAIPrompt as any;
  const appendToValue = rootRef.current ?? undefined;

  return <InlineAny {...(rest as any)} appendTo={appendToValue} anchor={anchor} />;
}
