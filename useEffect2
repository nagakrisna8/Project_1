useEffect(() => {
    if (!promptRoot) return;

    // Tweak selector if your three-line button differs.
    const buttonSelector = 'button[title="Commands Button"], button[aria-label="Commands Button"], .k-button.k-icon-button';

    const handler = (ev: PointerEvent | MouseEvent) => {
      try {
        const target = ev.target as HTMLElement | null;
        if (!target) return;

        // Find the actual button element (handles clicks on svg/span inside the button)
        const btn = target.closest && (target.closest(buttonSelector) as HTMLElement | null);
        if (!btn) return;

        // Only handle buttons that are inside the prompt area (safety)
        if (!promptRoot.contains(btn) && !btn.closest('.k-prompt-content') && !btn.closest('.k-inlineai')) return;

        // Save scroll position (backup)
        const sx = window.scrollX || window.pageXOffset || 0;
        const sy = window.scrollY || window.pageYOffset || 0;

        // Prevent browser default action (this prevents native focus/scroll)
        ev.preventDefault();
        ev.stopPropagation();

        // Fire a real click so the library receives it (next tick)
        setTimeout(() => {
          const clickEvent = new MouseEvent('click', { view: window, bubbles: true, cancelable: true });
          btn.dispatchEvent(clickEvent);
        }, 0);

        // Restore scroll immediately and a few times after to cover any late reflows
        setTimeout(() => window.scrollTo(sx, sy), 0);
        setTimeout(() => window.scrollTo(sx, sy), 30);
        setTimeout(() => window.scrollTo(sx, sy), 150);
      } catch (e) {
        // ignore
      }
    };

    // Use capture so we run before browser focus behavior
    document.addEventListener('pointerdown', handler, true);
    document.addEventListener('mousedown', handler, true);

    return () => {
      document.removeEventListener('pointerdown', handler, true);
      document.removeEventListener('mousedown', handler, true);
    };
  }, [promptRoot]);
